package org.abitoff.discord.sushirole.exceptions;

import java.security.GeneralSecurityException;
import java.util.Base64;
import java.util.EnumSet;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;

import javax.annotation.Nonnull;

import org.abitoff.discord.sushirole.exceptions.ThrowableReporter.ThrowableReportingException.ExceptionType;
import org.abitoff.discord.sushirole.pastebin.ConcurrentPastebinApi;
import org.abitoff.discord.sushirole.utils.LoggingUtils;
import org.abitoff.discord.sushirole.utils.Utils;

import com.github.kennedyoliveira.pastebin4j.AccountCredentials;
import com.github.kennedyoliveira.pastebin4j.PasteBin;
import com.google.crypto.tink.Aead;
import com.google.crypto.tink.KeysetHandle;
import com.google.crypto.tink.aead.AeadConfig;
import com.google.crypto.tink.aead.AeadFactory;

import ch.qos.logback.classic.Logger;
import net.dv8tion.jda.core.EmbedBuilder;
import net.dv8tion.jda.core.entities.MessageEmbed;
import net.dv8tion.jda.core.entities.TextChannel;

public class ThrowableReporter
{
	/** The color to use for error embeds */
	private static final int ERROR_EMBED_COLOR = 0xff0000;
	/**
	 * The max length of an error message to display in a Discord embed field. (See
	 * {@link ExceptionHandler#generateFieldMessage(Throwable) generateFieldMessage()})
	 */
	private static final int MAX_FIELD_MESSAGE_LENGTH = 128;
	/**
	 * The max number of Throwable {@link Throwable#getCause() causes} to append to a Discord embed. (See
	 * {@link ExceptionHandler#appendCauses(Throwable, EmbedBuilder) appendCauses()})
	 */
	private static final int MAX_CAUSES_PER_EMBED = 3;
	/**
	 * Format string which gets converted to the author name of an {@link MessageEmbed embed} in
	 * {@link ExceptionHandler#appendAuthorInformation(MessageHandlingException, EmbedBuilder) appendAuthorInformation()}
	 */
	private static final String EMBED_AUTHOR_FORMAT = "%guild%>%channel%>%user%";

	private final Logger log;
	private final TextChannel reportingChannel;
	private final PasteBin pastebin;
	private final Aead encryptor;

	public ThrowableReporter(Logger fileLogger, TextChannel devGuildReportingChannel, AccountCredentials pastebinCredentials,
			KeysetHandle AEADEncryptionKey)
	{
		this.log = fileLogger;
		this.reportingChannel = devGuildReportingChannel;
		if (pastebinCredentials != null)
			this.pastebin = new PasteBin(pastebinCredentials, ConcurrentPastebinApi.API);
		else
			this.pastebin = null;
		if (AEADEncryptionKey != null)
		{
			try
			{
				AeadConfig.register();
				this.encryptor = AeadFactory.getPrimitive(AEADEncryptionKey);
			} catch (GeneralSecurityException e)
			{
				throw new ThrowableReportingException("Exception while initiating Tink's AEAD service!", e,
						ExceptionType.ENCRYPTION);
			}
		} else
		{
			this.encryptor = null;
		}
	}

	public Logger getLogger()
	{
		return log;
	}

	public TextChannel getReportingDiscordChannel()
	{
		return reportingChannel;
	}

	public CompletableFuture<ThrowablePacket> reportThrowable(@Nonnull Throwable t)
	{
		Objects.requireNonNull(t, "The throwable must not be null!");
		return null;// processPacket(new ThrowablePacket(t, System.currentTimeMillis()));
	}

	public static class ThrowablePacket
	{
		private Throwable t;
		private long timestamp;

		public ThrowablePacket(Throwable t, long timestamp)
		{
			this.t = t;
			this.timestamp = timestamp;
		}
	}

	public static final class ErrorFileUtils
	{
		/** The byte array used to separate the header data from the encrypted data in the file generated and sent to Pastebin */
		public static final byte[] HEADER_SEPARATOR = new byte[] {'.'};

		/**
		 * Generates a byte array which encodes the given HeaderFlags
		 * 
		 * @param flags
		 *            the flags to encode
		 * @return the generated byte array
		 */
		public static byte[] generateHeader(EnumSet<HeaderFlag> flags)
		{
			int size = Utils.divideCeil(HeaderFlag.values().length, 8);
			byte[] header = new byte[size];

			for (HeaderFlag flag: flags)
			{
				int shift = flag.ordinal();
				int index = shift / 8;
				int subshift = shift % 8;
				byte bit = (byte) (128 >> subshift);
				header[index] |= bit;
			}

			byte[] encoded = Base64.getUrlEncoder().encode(header);

			return encoded;
		}

		/**
		 * Reads the header flags from an encoded byte array, returning the compiled set
		 * 
		 * @param header
		 *            the encoded bytes to read the header flags from
		 * @return the set of HeaderFlags obtained from the byte array
		 * @throws IllegalArgumentException
		 *             if {@code header} is not valid Base64
		 */
		public static EnumSet<HeaderFlag> generateFlags(byte[] header) throws IllegalArgumentException
		{
			byte[] decoded = Base64.getUrlDecoder().decode(header);
			EnumSet<HeaderFlag> flags = EnumSet.noneOf(HeaderFlag.class);
			HeaderFlag[] values = HeaderFlag.values();
			for (int i = 0; i < decoded.length; i++)
			{
				for (int j = 0; j < Byte.SIZE; j++)
				{
					int flag = 128 >> j;
					if ((decoded[i] & flag) != 0)
					{
						int ordinal = i * Byte.SIZE + j;
						try
						{
							flags.add(values[ordinal]);
						} catch (IndexOutOfBoundsException e)
						{
							LoggingUtils.warnf("%d is an unrecognized header flag! Either this software is out of date or the "
									+ "file is malformed!", ordinal);
						}
					}
				}
			}
			return flags;
		}

		/**
		 * A set of flags which are prepended to files uploaded to pastebin or discord.
		 * 
		 * @author Steven Fontaine
		 */
		public static enum HeaderFlag
		{
			ENCRYPTED
		}
	}

	public static class ThrowableReportingException extends RuntimeException
	{
		private static final long serialVersionUID = -2701521343262068254L;
		public final ExceptionType type;

		public ThrowableReportingException(ExceptionType type)
		{
			super();
			this.type = type;
		}

		public ThrowableReportingException(String message, ExceptionType type)
		{
			super(message);
			this.type = type;
		}

		public ThrowableReportingException(Throwable cause, ExceptionType type)
		{
			super(cause);
			this.type = type;
		}

		public ThrowableReportingException(String message, Throwable cause, ExceptionType type)
		{
			super(message, cause);
			this.type = type;
		}

		public ThrowableReportingException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace,
				ExceptionType type)
		{
			super(message, cause, enableSuppression, writableStackTrace);
			this.type = type;
		}

		public static enum ExceptionType
		{
			LOGGING,
			ENCRYPTION,
			PASTEBIN,
			DISCORD,
		}
	}
}
